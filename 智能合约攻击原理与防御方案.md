
# 《智能合约攻击原理与防御方案（工程实践版）》

> 面向 Solidity / EVM / DeFi 工程师
> 目标：**理解攻击为什么能发生 + 如何从设计层面避免**

---

## 目录

1. 重入攻击（Reentrancy）
2. 整数溢出与精度问题
3. 权限控制与所有权劫持
4. Delegatecall 与存储冲突
5. 未初始化合约攻击
6. Flash Loan（闪电贷）攻击
7. 预言机攻击
8. AMM / 价格操纵攻击
9. 清算与利率模型攻击
10. 治理攻击（Governance Attack）
11. MEV / 前置交易攻击
12. DoS（拒绝服务）攻击
13. 时间与区块依赖攻击
14. 签名与重放攻击
15. 跨链桥攻击
16. 安全设计总原则（Checklist）

---

## 1. 重入攻击（Reentrancy）

### 攻击原理

**本质**：
在**状态尚未更新之前**，合约进行了**外部调用**，攻击者通过 fallback / hook 再次进入当前函数，重复执行逻辑。

```solidity
function withdraw(uint amount) external {
    require(balance[msg.sender] >= amount);
    (bool ok,) = msg.sender.call{value: amount}(""); // 外部调用
    require(ok);
    balance[msg.sender] -= amount; // 状态更新太晚
}
```

攻击流程：

1. 攻击者调用 `withdraw`
2. 合约向攻击合约转账
3. fallback 中再次调用 `withdraw`
4. 余额尚未减少 → 可无限提取

---

### 解决方案

**1️⃣ Checks-Effects-Interactions**

```solidity
balance[msg.sender] -= amount;
(bool ok,) = msg.sender.call{value: amount}("");
require(ok);
```

**2️⃣ ReentrancyGuard**

```solidity
nonReentrant
```

**3️⃣ 设计层面**

* Pull over Push
* 避免在核心逻辑中直接外部调用
* ERC777 / hook 特别警惕

---

## 2. 整数溢出 / 精度问题

### 攻击原理

* Solidity <0.8 存在 wrap
* Vault / AMM 中 **share ↔ asset** 精度错误
* 小额操纵 → 大额收益

```solidity
shares = amount * totalShares / totalAssets;
```

当 `totalAssets` 被操纵为极小值时，shares 被放大。

---

### 解决方案

* Solidity ≥0.8
* 统一使用 **WAD / RAY**
* 所有比例计算加 `+1 / -1` 安全边界
* 审计所有 `mul / div` 顺序

---

## 3. 权限控制缺陷（Access Control）

### 攻击原理

* 关键函数未加 `onlyOwner`
* Role 管理错误
* Proxy 升级函数暴露

```solidity
function upgradeTo(address impl) external {
    _setImplementation(impl);
}
```

---

### 解决方案

* 明确权限分层（Owner / Admin / Guardian）
* 所有关键路径必须有 access modifier
* 多签 + Timelock
* 升级权限 ≠ 资金权限

---

## 4. Delegatecall 与存储冲突

### 攻击原理

`delegatecall`：

* 使用 **当前合约的 storage**
* 执行 **外部合约代码**

错误 storage layout ⇒ **覆盖关键变量**

---

### 常见事故

* Proxy implementation slot 冲突
* Diamond facet 变量重叠

---

### 解决方案

* EIP-1967 固定 slot
* Diamond 使用 namespace storage
* 禁止 implementation 定义状态变量
* 自动化 storage layout diff

---

## 5. 未初始化合约攻击

### 攻击原理

```solidity
function initialize() external {
    owner = msg.sender;
}
```

* initialize 未限制
* implementation 可被直接调用

攻击者直接成为 owner。

---

### 解决方案

* constructor 中 `_disableInitializers()`
* initialize 使用 `initializer` 修饰
* implementation 不应持有资产

---

## 6. 闪电贷攻击（Flash Loan）

### 攻击原理

**零成本、原子化、无限流动性**

攻击者在一个 transaction 内：

1. 借入巨额资金
2. 操纵系统状态（价格 / 份额 / 清算）
3. 获利
4. 归还贷款

---

### 被攻击系统特征

* 使用链上即时价格
* 无时间加权
* 状态变化无冷却期

---

### 解决方案

* 关键参数使用 TWAP
* 引入 delay / commit-reveal
* 风控上限（cap / rate limit）
* 使用外部预言机

---

## 7. 预言机攻击（Oracle）

### 攻击原理

* 单一 DEX 作为价格源
* 低流动性池
* 可被闪电贷操纵

---

### 解决方案

* 多源预言机
* Chainlink + sanity check
* 拉长 TWAP 窗口
* 禁止同 block 内读写价格

---

## 8. AMM / 价格操纵攻击

### 攻击形式

* Sandwich Attack
* 流动性瞬时抽空
* 人为制造滑点

---

### 解决方案

* 用户设置 minOut
* 协议限制滑点
* Batch Auction
* MEV-aware 设计

---

## 9. 清算 / 利率模型攻击

### 攻击原理

* 利率曲线突变
* 清算奖励过高
* 闪电贷触发连环清算

---

### 解决方案

* 平滑利率曲线
* 清算激励上限
* 限制单笔清算规模

---

## 10. 治理攻击（Governance）

### 攻击原理

* Flash Loan 借票
* Snapshot 治理
* 提案立即执行

---

### 解决方案

* 投票快照 ≠ 执行快照
* Timelock
* 投票权冷却期
* 反闪电贷权重机制

---

## 11. MEV / 前置交易

### 攻击原理

矿工 / Builder 可：

* 重排交易
* 插队
* 回滚区块

---

### 解决方案

* Commit-Reveal
* 私有交易池（Flashbots）
* 批量撮合

---

## 12. DoS 攻击

### 攻击方式

* 恶意 revert
* gas griefing
* 无限循环遍历

---

### 解决方案

* 避免 unbounded loop
* 分页处理
* try/catch

---

## 13. 时间 / 区块依赖

### 攻击原理

```solidity
if (block.timestamp % 2 == 0) win();
```

矿工可操纵 timestamp。

---

### 解决方案

* 仅用于宽松逻辑
* 不用于随机性
* 使用 VRF

---

## 14. 签名与重放攻击

### 攻击原理

* nonce 管理错误
* domain separator 配置错误
* 跨链重放

---

### 解决方案

* EIP-712
* per-user nonce
* chainId 绑定

---

## 15. 跨链桥攻击

### 攻击原理

* 验证器被攻破
* 消息伪造
* 状态不同步

---

### 解决方案

* 最小信任假设
* 多层验证
* 限额与熔断
* 延迟提款

---

## 16. 安全设计 Checklist（工程级）

* [ ] 状态更新在外部调用前
* [ ] 所有权限函数可枚举
* [ ] Proxy / Diamond storage 校验
* [ ] Oracle 多源 + 延迟
* [ ] Flash loan 威胁建模
* [ ] 升级可回滚
* [ ] 经济模型压力测试
* [ ] 历史攻击复盘


